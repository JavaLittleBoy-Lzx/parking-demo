# 超时监控改为后端定时任务说明

## 📋 优化概述

将停车超时监控从**前端小程序轮询**改为**后端定时任务**自动执行，提高系统稳定性和可靠性。

---

## ❌ 原方案问题

### 前端轮询方式（已废弃）

**实现位置**：`car-new-demo/utils/timeoutMonitoring.js`

**运行方式**：
```javascript
// 前端每1分钟轮询一次
this.checkInterval = 1 * 60 * 1000

// 调用后端API检查超时
const response = await timeoutAPI.checkRecentTimeout()
```

**存在问题**：
1. ❌ **依赖前端运行**：用户关闭小程序就停止监控
2. ❌ **不可靠**：网络不好、小程序被系统杀掉都会导致漏检
3. ❌ **消耗资源**：占用用户流量、电量、手机性能
4. ❌ **权限限制**：只有管家/业主打开小程序才能触发
5. ❌ **难以监控**：无法统一管理和查看执行状态

---

## ✅ 新方案优势

### 后端定时任务方式（推荐）

**实现位置**：`src/main/java/com/parkingmanage/task/ParkingTimeoutMonitoringTask.java`

**运行方式**：
```java
// Spring定时任务，每1分钟自动执行
@Scheduled(cron = "0 * * * * ?")
public void checkParkingTimeout()
```

**优势**：
1. ✅ **完全自动**：后端服务启动后自动运行，无需人工干预
2. ✅ **稳定可靠**：不受前端状态影响，24小时持续监控
3. ✅ **节省资源**：不消耗用户流量和电量
4. ✅ **集中管理**：统一的日志记录，便于监控和调试
5. ✅ **性能更好**：服务器性能强，处理速度快
6. ✅ **易于扩展**：可以方便地调整检查频率和逻辑

---

## 🔧 技术实现

### 1. 定时任务配置

```java
@Slf4j
@Component
public class ParkingTimeoutMonitoringTask {
    
    // cron = "0 * * * * ?" 表示每分钟的第0秒执行
    @Scheduled(cron = "0 * * * * ?")
    public void checkParkingTimeout() {
        // 自动执行超时检查
    }
}
```

### 2. 执行逻辑

```
每1分钟自动执行：
├─ 1. 查询2小时内活跃车辆
├─ 2. 计算每辆车的停车时长
├─ 3. 判断是否需要发送提醒
│   ├─ 剩余15分钟：发送提醒
│   ├─ 剩余5分钟：发送提醒
│   └─ 剩余1分钟：发送提醒
└─ 4. 根据预约类型智能分发
    ├─ 邀请预约：访客+管家+业主
    ├─ 代人预约：管家+业主
    └─ 其他类型：访客
```

### 3. 智能通知分发

| 预约类型 | 通知对象 | 数据来源 |
|---------|---------|---------|
| 邀请 | 访客 + 管家 + 业主 | appointment表的openid字段 |
| 代人 | 管家 + 业主 | appointment表的openid字段 |
| 自助/业主 | 访客 | appointment表的openid字段 |

---

## 📊 执行效果

### 日志示例

```log
⏰ [定时任务] 停车超时监控开始执行
📊 [定时任务] 发现 15 辆活跃车辆，开始检查超时情况
📧 [定时任务] 发送超时提醒 - 车牌: 京A12345, 预约类型: 邀请, 剩余: 15分钟
📧 [定时任务-邀请预约] 发送给：访客、管家、业主
✅ [定时任务] 即将超时提醒(剩余15分钟)(访客)发送成功 - openid: oXXXX
✅ [定时任务] 即将超时提醒(剩余15分钟)(管家)发送成功 - openid: oYYYY
✅ [定时任务] 即将超时提醒(剩余15分钟)(业主)发送成功 - openid: oZZZZ
📊 [定时任务] 通知发送完成 - 车牌: 京A12345, 成功: 3/3
✅ [定时任务] 检查完成 - 活跃: 15辆, 即将超时: 8辆, 已超时: 3辆, 发送通知: 12条
```

---

## 🚀 部署说明

### 1. 确认定时任务已启用

检查主启动类是否有`@EnableScheduling`注解：

```java
@SpringBootApplication
@EnableScheduling  // ✅ 已启用
public class ParkingManageApplication {
    // ...
}
```

位置：`src/main/java/com/parkingmanage/ParkingManageApplication.java`

### 2. 重启后端服务

```bash
# 停止旧服务
# 启动新服务

# 定时任务会自动开始运行
```

### 3. 查看日志确认运行

定时任务启动后，每1分钟会在日志中看到：
```
⏰ [定时任务] 停车超时监控开始执行
```

---

## 📝 前端调整建议

### 可选：移除前端监控代码

由于后端已经接管了超时监控，前端的轮询代码可以移除或禁用：

**位置**：`car-new-demo/utils/timeoutMonitoring.js`

**方案1：禁用自动监控**
```javascript
constructor() {
    this.autoMode = false  // 改为false，禁用前端监控
}
```

**方案2：完全删除**
- 删除 `utils/timeoutMonitoring.js`
- 删除 `api/timeout-monitoring.js`
- 移除相关页面的调用代码

### 保留前端API（可选）

如果需要手动触发检查或查看超时列表，可以保留以下API：
- `/parking/timeout/recent-active-count` - 查询活跃车辆数
- `/parking/timeout/check-recent` - 手动触发检查（可选）

---

## ⚙️ 配置说明

### 修改检查频率

如果需要调整检查频率，修改cron表达式：

```java
// 当前：每1分钟
@Scheduled(cron = "0 * * * * ?")

// 改为每30秒
@Scheduled(cron = "0,30 * * * * ?")

// 改为每2分钟
@Scheduled(cron = "0 */2 * * * ?")

// 改为每5分钟
@Scheduled(cron = "0 */5 * * * ?")
```

### Cron表达式说明

格式：`秒 分 时 日 月 星期`

| 表达式 | 含义 |
|--------|------|
| `0 * * * * ?` | 每分钟的第0秒执行 |
| `0 */2 * * * ?` | 每2分钟执行 |
| `0 */5 * * * ?` | 每5分钟执行 |
| `0 0 * * * ?` | 每小时执行 |

---

## 🔍 监控和维护

### 1. 查看执行日志

```bash
# 查看定时任务日志
tail -f logs/spring.log | grep "定时任务"
```

### 2. 监控执行状态

定时任务会在日志中记录：
- ✅ 检查的车辆数量
- ✅ 发送通知的数量
- ✅ 成功/失败情况
- ⚠️ 异常错误信息

### 3. 临时停止定时任务

如果需要临时停止，可以注释掉`@Scheduled`注解：

```java
// @Scheduled(cron = "0 * * * * ?")
public void checkParkingTimeout() {
    // 注释后不会自动执行
}
```

---

## 🎯 对比总结

| 对比项 | 前端轮询 | 后端定时任务 |
|--------|---------|-------------|
| **可靠性** | ❌ 低 | ✅ 高 |
| **稳定性** | ❌ 依赖前端 | ✅ 独立运行 |
| **性能** | ❌ 消耗用户资源 | ✅ 服务器处理 |
| **监控** | ❌ 难以统一管理 | ✅ 集中日志管理 |
| **维护** | ❌ 前后端都要改 | ✅ 只需改后端 |
| **扩展性** | ❌ 受限于前端 | ✅ 灵活配置 |

---

## ✨ 总结

- ✅ **后端定时任务**已创建并可正常运行
- ✅ **无需人工干预**，服务启动后自动执行
- ✅ **稳定可靠**，24小时持续监控
- ✅ **智能分发**，根据预约类型自动通知相关人员
- 📝 **前端代码**可以保留（但不会再触发）或删除

**建议**：重启后端服务后，观察日志确认定时任务正常运行，然后可以逐步移除前端的监控代码。

---

**修改时间**：2024-12-04  
**修改人**：AI Assistant  
**影响范围**：超时监控功能
