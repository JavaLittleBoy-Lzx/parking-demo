# 🎯 预约逻辑修改说明

## 📌 修改需求

根据业务需求，调整车辆预约的重复预约校验逻辑：

### 原有问题
1. ❌ 检查车牌是否有未离场记录时，没有时间限制
2. ❌ 提示信息不够明确
3. ❌ 定时任务每小时执行一次，过期标记不及时

### 新需求
1. ✅ **相同手机号的不同车牌**：允许同时预约（不限制）
2. ✅ **相同车牌未失效**：不允许再次预约（依赖定时任务标记过期）
3. ✅ **定时任务**：每10分钟执行一次，及时标记过期记录
4. ✅ **提示信息**：明确告知用户"该车牌已经预约过并且还未失效"

---

## 🔧 修改内容

### 1️⃣ 定时任务修改

**文件位置**：`AppointmentExpirationTask.java`

#### 修改：定时任务执行频率从每小时改为每10分钟

**位置**：第52行（Cron表达式）、第82行（更新字段）

**修改内容**：

1. **Cron表达式修改**
```java
/**
 * 每10分钟执行一次，检查并标记过期的预约记录
 * 
 * 执行时间：每10分钟执行一次（0分、10分、20分、30分、40分、50分）
 * 
 * 过期规则：
 * 1. 预约状态为"待入场"（venuestatus='待入场'）
 * 2. 审核状态为已通过（auditstatus='已通过' 或 '不审核'）
 * 3. 创建时间超过24小时（recorddate < now - 24小时）
 * 
 * 处理方式：
 * - 将 venuestatus 更新为 '已过期'
 * - 记录过期时间到 updatetime（而非 auditdate）
 */
@Scheduled(cron = "0 */10 * * * ?")  // 从 "0 15 * * * ?" 改为 "0 */10 * * ?"
```

2. **更新字段修改**
```java
// 批量更新为已过期状态
UpdateWrapper<Appointment> updateWrapper = new UpdateWrapper<>();
updateWrapper.eq("venuestatus", "待入场")
            .in("auditstatus", "已通过", "不审核")
            .lt("recorddate", expirationTime)
            .set("venuestatus", "已过期")
            .set("updatetime", now);  // ✅ 改为写入 updatetime，不再写入 auditdate
```

**关键改动**：
- ❌ **移除**：`.set("auditdate", now)` - 不再写入审批时间
- ✅ **新增**：`.set("updatetime", now)` - 写入更新时间字段

### 2️⃣ 重复预约校验逻辑修改

**文件位置**：`AppointmentController.java`

#### 修改1：更新重复预约校验逻辑注释和提示

**位置**：第109-123行

```java
// 🚫 第三步：车牌重复预约校验（相同车牌未失效不允许再次预约）
// 注意：只检查车牌号，不检查手机号（相同手机号的不同车牌可以同时预约）
// 过期判断由定时任务（每10分钟）自动处理，这里只查询状态即可
try {
    logger.info("🚫 开始车牌重复预约校验: {}", plateNumber);
    boolean hasActiveAppointment = checkActiveParkingStatus(plateNumber, appointment.getCommunity());
    if (hasActiveAppointment) {
        logger.warn("🚫 车牌号 {} 已有未失效的预约记录，拒绝重复预约", plateNumber);
        return R.failed("该车牌已经预约过并且还未失效，请等待车辆离场或预约过期后再次预约");
    }
    logger.info("✅ 车牌号 {} 重复预约校验通过（无未失效记录）", plateNumber);
} catch (Exception e) {
    logger.error("🚫 重复预约校验异常: {}", e.getMessage(), e);
    return R.failed("重复预约校验失败，请稍后重试");
}
```

#### 修改2：简化 `checkActiveParkingStatus` 方法

**位置**：第1543-1597行

```java
/**
 * 检查车牌号是否有未失效的预约记录（重复预约检查）
 * 注意：只检查车牌号，不检查手机号（相同手机号的不同车牌可以同时预约）
 * 依赖定时任务（每10分钟执行）自动标记过期记录，这里只查询venuestatus状态即可
 * @param plateNumber 车牌号
 * @param community 社区名称
 * @return true-存在未失效的预约记录，false-不存在
 */
private boolean checkActiveParkingStatus(String plateNumber, String community) {
    try {
        // 查询该车牌号在该社区的预约记录，排除已离场和已过期的记录
        // 不再手动计算24小时，完全依赖定时任务标记的"已过期"状态
        QueryWrapper<Appointment> queryWrapper = new QueryWrapper<>();
        
        queryWrapper.eq("platenumber", plateNumber)
                   .eq("community", community)
                   .ne("venuestatus", "已离场")  // 排除已离场的记录
                   .ne("venuestatus", "已过期")  // 排除已过期的记录（由定时任务标记）
                   .isNotNull("venuestatus");     // 确保场地状态不为空
        
        long count = appointmentService.count(queryWrapper);
        
        if (count > 0) {
            logger.warn("🚫 发现车牌 {} 在 {} 有 {} 条未失效的预约记录", plateNumber, community, count);
            
            // 记录详细信息用于调试
            QueryWrapper<Appointment> detailWrapper = new QueryWrapper<>();
            detailWrapper.eq("platenumber", plateNumber)
                       .eq("community", community)
                       .ne("venuestatus", "已离场")
                       .ne("venuestatus", "已过期")
                       .isNotNull("venuestatus")
                       .orderByDesc("recorddate");
            
            List<Appointment> activeAppointments = appointmentService.list(detailWrapper);
            if (activeAppointments != null && !activeAppointments.isEmpty()) {
                for (Appointment app : activeAppointments) {
                    logger.warn("   - 预约ID: {}, 场地状态: {}, 审核状态: {}, 预约时间: {}, 记录时间: {}", 
                        app.getId(), app.getVenuestatus(), app.getAuditstatus(), 
                        app.getVisitdate(), app.getRecorddate());
                }
            }
            return true;
        }
        
        logger.info("✅ 车牌 {} 在 {} 无未失效的预约记录", plateNumber, community);
        return false;
    } catch (Exception e) {
        logger.error("🚫 重复预约检查异常: {}", e.getMessage(), e);
        // 异常情况下，为了安全起见，选择允许预约但记录日志
        return false;
    }
}
```

**关键改动**：
- ✅ **移除了24小时时间计算**：`.ge("recorddate", twentyFourHoursAgo)` 已删除
- ✅ **完全依赖定时任务**：只检查 `venuestatus` 状态
- ✅ **简化了逻辑**：定时任务每10分钟自动标记过期，这里无需手动计算

---

## 📊 修改要点

### ✅ 实现的功能

1. **24小时时间限制**
   - 添加了 `.ge("recorddate", twentyFourHoursAgo)` 条件
   - 只检查24小时内的预约记录
   - 超过24小时的预约不受影响

2. **排除已过期记录**
   - 添加了 `.ne("venuestatus", "已过期")` 条件
   - 已过期的预约不算作未离场

3. **只检查车牌号**
   - 方法只接收 `plateNumber` 和 `community` 参数
   - **不检查手机号**
   - 相同手机号的不同车牌可以同时预约

4. **明确的提示信息**
   - 用户看到：`"该车牌在24小时内已经预约过并且还未失效，请等待车辆离场后再次预约"`
   - 明确告知是"24小时内"和"还未失效"

### 📋 校验逻辑

```
用户提交预约
    ↓
检查车牌号 + 小区
    ↓
查询条件：
  1. platenumber = 输入的车牌号
  2. community = 选择的小区
  3. venuestatus != '已离场'
  4. venuestatus != '已过期'
  5. recorddate >= 24小时前
    ↓
如果存在记录 → 拒绝预约（提示：该车牌在24小时内已经预约过）
如果不存在   → 允许预约
```

---

## 🧪 测试场景

### 场景1：相同手机号，不同车牌
- **手机号**：13800138000
- **第一次预约**：粤A12345 → ✅ 允许
- **第二次预约**：粤A54321 → ✅ 允许（不同车牌，不限制）

### 场景2：相同车牌，24小时内
- **车牌号**：粤A12345
- **第一次预约**：2024-12-06 09:00 → ✅ 允许
- **第二次预约**：2024-12-06 10:00（未离场）→ ❌ 拒绝
- **提示**："该车牌在24小时内已经预约过并且还未失效"

### 场景3：相同车牌，超过24小时
- **车牌号**：粤A12345
- **第一次预约**：2024-12-05 08:00 → ✅ 允许
- **第二次预约**：2024-12-06 09:00（超过24小时）→ ✅ 允许（超过24小时限制）

### 场景4：相同车牌，已离场
- **车牌号**：粤A12345
- **第一次预约**：2024-12-06 09:00，10:00离场 → ✅ 允许
- **第二次预约**：2024-12-06 11:00 → ✅ 允许（已离场，不算未离场记录）

---

## 🎯 注意事项

1. **前端无需修改**
   - 前端只需要处理后端返回的错误提示即可
   - 错误信息会自动显示给用户

2. **数据库索引建议**
   - 考虑在 `appointment` 表上添加复合索引：
   ```sql
   CREATE INDEX idx_plate_community_venue_record 
   ON appointment(platenumber, community, venuestatus, recorddate);
   ```

3. **日志记录**
   - 所有重复预约的拒绝都会记录详细日志
   - 便于后续分析和调试

---

## 📦 数据库变更

### 新增 updatetime 字段

**文件位置**：`Appointment.java` 第64-67行

```java
@ApiModelProperty(value = "更新时间")
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
@TableField(fill = FieldFill.INSERT_UPDATE)
private LocalDateTime updatetime;
```

**字段说明**：
- **字段名称**：`updatetime`
- **字段类型**：`DATETIME`
- **自动填充**：`FieldFill.INSERT_UPDATE`（插入和更新时自动填充）
- **用途**：记录预约的最后更新时间，定时任务标记过期时会更新此字段

### 数据库迁移脚本

**文件位置**：`docs/add_updatetime_field.sql`

执行以下SQL语句添加字段：

```sql
-- 为 appointment 表添加 updatetime 字段
ALTER TABLE appointment 
ADD COLUMN updatetime DATETIME COMMENT '更新时间';

-- 为现有记录设置初始值（使用 recorddate 作为初始更新时间）
UPDATE appointment 
SET updatetime = recorddate 
WHERE updatetime IS NULL;

-- 创建索引以优化查询性能
CREATE INDEX idx_updatetime ON appointment(updatetime);
```

**注意事项**：
1. 需要在生产环境执行此迁移脚本
2. 现有记录的 `updatetime` 会被初始化为 `recorddate`
3. 新记录会由 MyBatis-Plus 自动填充
4. 定时任务标记过期时会更新此字段

---

## ✅ 修改完成

修改已完成，主要变更：

### 代码层面
1. ✅ 定时任务从每小时改为每10分钟执行
2. ✅ 定时任务更新字段从 `auditdate` 改为 `updatetime`
3. ✅ 移除手动24小时时间计算
4. ✅ 简化重复预约检查，完全依赖定时任务标记的状态
5. ✅ 只检查车牌号（不检查手机号）
6. ✅ 明确的用户提示信息

### 数据库层面
7. ✅ 新增 `updatetime` 字段（需执行迁移脚本）
8. ✅ 为 `updatetime` 字段创建索引

### 前端
- ✅ 前端会自动接收并显示新的错误提示信息，无需额外修改
