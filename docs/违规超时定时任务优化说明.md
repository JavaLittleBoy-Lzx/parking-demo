# 违规超时定时任务优化说明

## 📋 优化背景

### 原有实现的问题

1. **查询范围过大**：每次查询所有2小时内的活跃车辆
   ```java
   LocalDateTime twoHoursAgo = LocalDateTime.now().minusHours(2);
   List<Appointment> recentActive = appointmentService.getRecentActiveAppointments(twoHoursAgo);
   ```

2. **效率低下**：
   - 对每辆车都要计算停车时长
   - 大量车辆不在通知时间点（30/60/90/105分钟），但仍被查询
   - 同一辆车在多次定时任务中被反复查询和计算

3. **不适合刚进场的车辆**：
   - 例如：5分钟前进场的车辆，不需要任何通知
   - 但仍会被查询出来并计算，浪费资源

## 🔥 优化方案

### 核心思路

**精准查询策略**：根据进场时间精准查询需要通知的车辆，避免查询和计算不必要的数据。

### 实现逻辑

1. **分4次精准查询**，每次只查询符合特定时间点的车辆：
   - 查询 **29-31分钟前** 进场的车辆 → 发送 **30分钟** 滞留通知（车主）
   - 查询 **59-61分钟前** 进场的车辆 → 发送 **60分钟** 滞留通知（车主）
   - 查询 **89-91分钟前** 进场的车辆 → 发送 **90分钟** 超时提醒（巡检员、管家）
   - 查询 **104-106分钟前** 进场的车辆 → 发送 **105分钟** 超时提醒（巡检员、管家）

2. **±1分钟容差**：给每个时间点设置±1分钟的容差，避免因定时任务执行时间偏差导致漏发

## 优化效果对比

| 对比项 | 优化前 | 优化后 |
|--------|--------|--------|
| 查询范围 | 2小时内所有车辆 | 仅4个时间点（±1分钟） |
| 查询次数/分钟 | 1次 | 4次 |
| 单次查询数据量 | 大（所有2小时内车辆） | 小（只有符合时间点的车辆） |
| 计算停车时长 | 每辆车都要计算 | 仅用于日志和通知内容 |
| 重复处理 | 同一辆车被反复查询 | 每辆车只在特定时间点查询一次 |

### 性能提升示例

假设停车场有100辆车在场：
- **优化前**：每分钟查询100辆车，逐个计算停车时长，判断是否需要通知
- **优化后**：每分钟只查询0-8辆车（每个时间点0-2辆），直接发送通知

**效率提升**：查询和计算量减少 **90%以上**

## 🛠️ 技术实现

### 1. 新增精准查询方法

**AppointmentService.java**

```java
/**
 * 🔥 【优化】根据进场时间范围精准查询车辆
 * 用于定时任务精准查询特定时间点的车辆，避免查询所有2小时内的车辆
 * 
 * @param startTime 进场开始时间
 * @param endTime 进场结束时间
 * @return 在该时间段内进场的活跃车辆列表
 */
List<Appointment> getActiveAppointmentsByTimeRange(
    java.time.LocalDateTime startTime, 
    java.time.LocalDateTime endTime
);
```

**AppointmentServiceImpl.java**

```java
@Override
public List<Appointment> getActiveAppointmentsByTimeRange(
    LocalDateTime startTime, 
    LocalDateTime endTime
) {
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    String startTimeStr = startTime.format(formatter);
    String endTimeStr = endTime.format(formatter);
    
    LambdaQueryWrapper<Appointment> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.isNotNull(Appointment::getArrivedate)           // 进场时间不为空
               .ge(Appointment::getArrivedate, startTimeStr)     // 进场时间 >= 开始时间
               .le(Appointment::getArrivedate, endTimeStr)       // 进场时间 <= 结束时间
               .eq(Appointment::getVenuestatus, "已入场")        // 场地状态为已入场
               .orderByAsc(Appointment::getArrivedate);          // 按进场时间升序
    
    return this.list(queryWrapper);
}
```

### 2. 重写定时任务逻辑

**ParkingTimeoutMonitoringTask.java**

```java
@Scheduled(cron = "0 * * * * ?")
public void checkParkingTimeout() {
    try {
        log.info("🔥 [定时任务-优化版] 停车超时监控开始执行");
        
        // 清理过期缓存
        cleanExpiredCache();
        
        LocalDateTime now = LocalDateTime.now();
        int totalNotified = 0;
        
        // 🔥 【优化】分别查询4个时间点的车辆
        // 1. 查询30分钟前进场的车辆（29-31分钟范围）
        totalNotified += checkAndNotifyByTimePoint(now, 30, "retention", "车主滞留通知");
        
        // 2. 查询60分钟前进场的车辆（59-61分钟范围）
        totalNotified += checkAndNotifyByTimePoint(now, 60, "retention", "车主滞留通知");
        
        // 3. 查询90分钟前进场的车辆（89-91分钟范围）
        totalNotified += checkAndNotifyByTimePoint(now, 90, "timeout", "超时提醒(剩余30分钟)");
        
        // 4. 查询105分钟前进场的车辆（104-106分钟范围）
        totalNotified += checkAndNotifyByTimePoint(now, 105, "timeout", "超时提醒(剩余15分钟)");
        
        log.info("✅ [定时任务-优化版] 检查完成 - 发送通知: {}条", totalNotified);
        
        // 检查万象上东VIP月票车拉黑条件
        checkWanXiangVipBlacklist();
        
    } catch (Exception e) {
        log.error("❌ [定时任务-优化版] 停车超时监控执行异常", e);
    }
}
```

### 3. 核心方法：checkAndNotifyByTimePoint

```java
/**
 * 🔥 【核心方法】检查并通知特定时间点的车辆
 * 
 * @param now 当前时间
 * @param minutesAgo 多少分钟前进场（30/60/90/105）
 * @param notifyType 通知类型：retention=滞留通知，timeout=超时提醒
 * @param notifyDesc 通知描述
 * @return 发送成功的通知数量
 */
private int checkAndNotifyByTimePoint(
    LocalDateTime now, 
    int minutesAgo, 
    String notifyType, 
    String notifyDesc
) {
    try {
        // 1. 计算时间范围（±1分钟容差）
        LocalDateTime startTime = now.minusMinutes(minutesAgo + 1);  // 例如：31分钟前
        LocalDateTime endTime = now.minusMinutes(minutesAgo - 1);    // 例如：29分钟前
        
        // 2. 精准查询该时间段进场的车辆
        List<Appointment> appointments = appointmentService
            .getActiveAppointmentsByTimeRange(startTime, endTime);
        
        if (appointments.isEmpty()) {
            log.debug("⏭️ [{}分钟通知] 无符合条件的车辆", minutesAgo);
            return 0;
        }
        
        log.info("📊 [{}分钟通知] 发现 {} 辆车辆，准备发送{}", 
            minutesAgo, appointments.size(), notifyDesc);
        
        // 3. 遍历车辆，检查并发送通知
        int successCount = 0;
        for (Appointment appointment : appointments) {
            // 检查夜间推送时段
            // 检查是否已发送（缓存去重）
            // 发送通知
            if (sendNotification(...)) {
                successCount++;
            }
        }
        
        return successCount;
        
    } catch (Exception e) {
        log.error("❌ [{}分钟通知] 执行异常", minutesAgo, e);
        return 0;
    }
}
```

## 📝 通知规则

### 30分钟 & 60分钟 - 车主滞留通知

- **发送对象**：车主（访客/业主）
- **通知类型**：滞留通知
- **发送逻辑**：
  - 邀请预约：通知访客
  - 代人预约：通知业主
  - 其他类型：通知访客

### 90分钟 & 105分钟 - 超时提醒

- **发送对象**：巡检员、管家
- **通知类型**：超时提醒
- **发送逻辑**：
  - 90分钟：剩余30分钟超时
  - 105分钟：剩余15分钟超时
  - 同时通知：
    - 值班巡检员（当前车场）
    - 管家（代人预约）
    - 业主（邀请预约/代人预约）

## 🎯 关键特性

### 1. 夜间推送控制

根据进场时间+停车时长计算当前时间是否在夜间时段（默认23:00-06:00）

```java
boolean isInNightTime = isInNotificationTimeByDuration(arriveDateTime, parkingMinutes);
```

### 2. 缓存去重机制

避免重复发送通知：

```java
String cacheKey = generateCacheKey(appointment.getId(), minutesAgo);
if (!isAlreadySent(cacheKey)) {
    // 发送通知
    markAsSent(cacheKey);
}
```

缓存键格式：`appointmentId_minutesAgo`
- 例如：`123_30` 表示预约ID 123 在30分钟时间点

### 3. 夜间推送控制（仅万象上东车场）

**特殊规则**：万象上东车场有特殊的违规判定规则

#### 业务规则

- **万象上东车场**：只在夜间（23:00-06:00）才算违规，白天停车不算违规
- **其他车场**：全天候监控，不受时间段限制

#### 实现逻辑

```java
// 只对万象上东车场启用夜间限制
if ("万象上东".equals(appointment.getCommunity())) {
    boolean isInNightTime = isInNotificationTimeByDuration(arriveDateTime, parkingMinutes);
    if (!isInNightTime) {
        log.debug("⏭️ [万象上东] 车牌 {} 当前不在夜间推送时段（23:00-06:00），白天不算违规，跳过通知", 
            appointment.getPlatenumber());
        continue;
    }
    log.debug("✅ [万象上东] 车牌 {} 在夜间时段，继续发送通知", appointment.getPlatenumber());
}
// 其他车场直接继续发送通知，不做时间限制
```

#### 时间判断方法

根据**进场时间 + 停车时长**计算当前时间是否在夜间时段：

```java
private boolean isInNotificationTimeByDuration(LocalDateTime arriveDateTime, long parkingMinutes) {
    // 1. 计算当前时间 = 进场时间 + 停车时长
    LocalDateTime currentTime = arriveDateTime.plusMinutes(parkingMinutes);
    LocalTime currentTimeOnly = currentTime.toLocalTime();
    
    // 2. 从配置表读取夜间时段（默认 23:00-06:00）
    LocalTime startTime = LocalTime.parse("23:00");
    LocalTime endTime = LocalTime.parse("06:00");
    
    // 3. 判断是否在夜间时段
    if (startTime.isAfter(endTime)) {
        // 跨日情况（如 23:00-06:00）
        return !currentTimeOnly.isBefore(startTime) || currentTimeOnly.isBefore(endTime);
    }
}
```

**示例**：
- 车辆早上9:00进场，停车1小时 → 当前时间10:00 → **不在夜间时段** → 万象上东跳过通知，其他车场正常发送
- 车辆晚上23:30进场，停车1小时 → 当前时间00:30 → **在夜间时段** → 所有车场都发送通知
- 车辆晚上22:00进场，停车2小时 → 当前时间00:00 → **在夜间时段** → 所有车场都发送通知

### 4. 自动清理过期缓存

每次定时任务执行时，清理30分钟前的过期缓存记录：

```java
cleanExpiredCache();
```

## 🔍 数据库查询示例

### 优化前（查询2小时内所有车辆）

```sql
SELECT * FROM appointment
WHERE arrivedate >= '2024-12-09 15:00:00'  -- 2小时前
  AND venuestatus = '已入场'
ORDER BY arrivedate ASC
```

**结果**：可能返回100辆车

### 优化后（精准查询30分钟前进场的车辆）

```sql
SELECT * FROM appointment
WHERE arrivedate >= '2024-12-09 16:29:00'  -- 31分钟前
  AND arrivedate <= '2024-12-09 16:31:00'  -- 29分钟前
  AND venuestatus = '已入场'
ORDER BY arrivedate ASC
```

**结果**：可能只返回0-2辆车

## ✅ 优化优势总结

1. **查询效率提升**
   - 只查询需要通知的车辆
   - 单次查询数据量减少90%以上

2. **计算量减少**
   - 无需逐个计算停车时长
   - 只在需要时才计算（用于日志和通知内容）

3. **避免重复处理**
   - 每辆车只在特定时间点查询一次
   - 缓存机制确保不重复发送

4. **根据进场时间判断**
   - 符合用户需求："根据进场时间来判断"
   - 不再依赖"2小时活跃车辆"这个不合理的范围

5. **数据库压力减小**
   - 查询条件更精准
   - 返回数据量更小
   - 数据库IO减少

## 🧪 测试建议

### 测试场景1：正常通知流程

1. 车辆进场
2. 等待30分钟 → 检查车主是否收到滞留通知
3. 等待60分钟 → 检查车主是否收到第二次滞留通知
4. 等待90分钟 → 检查巡检员、管家是否收到超时提醒
5. 等待105分钟 → 检查巡检员、管家是否收到第二次超时提醒

### 测试场景2：性能测试

1. 准备100辆在场车辆（不同进场时间）
2. 观察定时任务执行日志
3. 对比查询数据量：
   - 优化前：每次查询100辆
   - 优化后：每次查询0-2辆

### 测试场景3：边界测试

- 进场时间刚好在29分钟 → 应该被查询到
- 进场时间刚好在31分钟 → 应该被查询到
- 进场时间在28分钟 → 不应该被查询到
- 进场时间在32分钟 → 不应该被查询到

## 📚 相关文件

- `AppointmentService.java` - 新增精准查询方法接口
- `AppointmentServiceImpl.java` - 实现精准查询方法
- `ParkingTimeoutMonitoringTask.java` - 重写定时任务逻辑

## 📅 更新日期

2024-12-09

---

**优化完成** ✅
