# 预约成功推送功能实现说明

## 功能概述

为管家代人预约和访客扫描邀请码两种预约方式添加了微信公众号消息推送功能，实现预约成功后自动通知相关人员。

## 推送规则

### 1. 管家代人预约（appointtype = "代办"）
- **推送对象**：访客（通过访客手机号查找对应的微信openid）
- **推送时机**：预约创建成功且审核状态为"已通过"
- **推送内容**：
  - 停车场名称
  - 车牌号（支持多个车牌，逗号分隔）
  - 预约时间
  - 温馨提示：您的车辆预约已成功，请按时到达停车场

### 2. 访客扫描邀请码（appointtype = "邀请"）
- **推送对象**：管家（使用预约记录中的auditopenid）
- **推送时机**：预约创建成功且审核状态为"已通过"
- **推送内容**：
  - 停车场名称
  - 车牌号（支持多个车牌，逗号分隔）
  - 预约时间
  - 温馨提示：访客车辆预约成功，请及时关注访客到访情况

## 多车牌号处理

系统支持一次预约多个车牌号：
- 多个车牌号在推送时会合并成一个字符串（逗号分隔）
- 如果车牌号字符串超过20个字符，系统会自动截断并添加"..."
- 微信模板消息字段长度限制：20个字符

## 实现细节

### 后端实现

#### 1. 服务接口（WeChatTemplateMessageService.java）
```java
/**
 * 发送车辆预约成功通知
 * @param openid 接收者openid
 * @param plateNumbers 车牌号列表（支持多个车牌）
 * @param parkName 停车场名称
 * @param appointmentTime 预约时间
 * @param appointType 预约类型（代办/邀请）
 * @return 发送结果
 */
Map<String, Object> sendAppointmentSuccessNotification(String openid, String plateNumbers, 
        String parkName, String appointmentTime, String appointType);
```

#### 2. 服务实现（WeChatTemplateMessageServiceImpl.java）
- 实现了`sendAppointmentSuccessNotification`方法
- 添加了`getOpenidByPhone`方法，通过手机号查询微信openid
- 模板消息字段映射：
  - `thing1`: 停车场名称
  - `car_number2`: 车牌号
  - `time3`: 预约时间
  - `thing4`: 温馨提示

#### 3. 控制器（AppointmentController.java）
- 在`insertAppointment`方法中，预约保存成功后调用`sendAppointmentSuccessNotification`
- 添加了`sendAppointmentSuccessNotification`私有方法，负责判断推送条件和获取接收者openid
- 添加了`getOpenidByPhone`私有方法，通过UserMappingService查询openid
- 注入了`UserMappingService`依赖

#### 4. 配置文件（application.yml）
```yaml
wechat:
  template:
    appointment:
      success: REPLACE_WITH_YOUR_TEMPLATE_ID  # 预约成功通知模板ID
```

## 微信公众平台配置步骤

### 1. 申请模板消息
登录微信公众平台 → 功能 → 模板消息 → 选择合适的模板或自定义模板

### 2. 推荐模板格式
**模板标题**：预约成功通知

**模板内容**：
```
园区名称：{{thing1.DATA}}
车牌号：{{car_number2.DATA}}
预约时间：{{time3.DATA}}
温馨提示：{{thing4.DATA}}
```

**字段说明**：
- `thing1`: 短文本，用于显示停车场/园区名称（20字以内）
- `car_number2`: 车牌号，支持多个车牌（20字以内）
- `time3`: 时间，格式如"2024-12-03 14:30:00"
- `thing4`: 短文本，用于显示温馨提示（20字以内）

### 3. 获取模板ID
- 申请模板后，微信会分配一个模板ID（格式如：xxxxxxxxxxxxxxxxxxxxx）
- 将该模板ID复制到`application.yml`配置文件中：
  ```yaml
  wechat:
    template:
      appointment:
        success: 你的模板ID
  ```

### 4. 重启服务
修改配置文件后需要重启Spring Boot应用使配置生效。

## 数据流转

```
用户操作（管家代人预约/访客扫描邀请码）
    ↓
前端提交预约请求到 /parking/appointment/insertAppointment
    ↓
AppointmentController.insertAppointment() 保存预约记录
    ↓
预约保存成功 → sendAppointmentSuccessNotification()
    ↓
判断预约类型和审核状态
    ↓
获取接收者openid（代办：通过访客手机号查询；邀请：使用管家openid）
    ↓
调用 WeChatTemplateMessageService.sendAppointmentSuccessNotification()
    ↓
构建模板消息参数并发送到微信服务器
    ↓
微信服务器推送消息到用户微信
```

## 日志说明

系统在推送过程中会记录详细日志，便于排查问题：

- `🔔 [开始发送预约成功通知]`：开始发送通知
- `📱 [管家代人预约]`：管家代人预约，显示访客手机号和openid
- `🎫 [访客扫描邀请码]`：访客扫描邀请码，显示管家openid
- `✅ [预约成功通知发送成功]`：通知发送成功
- `⚠️ [预约成功通知发送失败]`：通知发送失败，会显示失败原因
- `❌ [预约成功通知发送异常]`：通知发送过程出现异常
- `⏭️ [预约成功通知跳过]`：不符合推送条件，跳过发送

## 错误处理

1. **推送失败不影响预约流程**：即使微信推送失败，预约记录仍会正常保存
2. **自动跳过不符合条件的预约**：
   - 非"代办"或"邀请"类型的预约不推送
   - 审核状态不是"已通过"的预约不推送
   - 访客手机号为空或找不到对应openid时跳过（代办类型）
   - 管家openid为空时跳过（邀请类型）
3. **详细的日志记录**：所有推送操作都会记录日志，便于问题排查

## 测试建议

### 1. 管家代人预约测试
1. 确保访客手机号已在`user_mapping`表中有对应的openid记录
2. 管家提交代人预约
3. 检查访客微信是否收到预约成功通知
4. 查看后端日志确认推送状态

### 2. 访客扫描邀请码测试
1. 管家生成访客邀请二维码
2. 访客扫描二维码并完成预约
3. 检查管家微信是否收到预约成功通知
4. 查看后端日志确认推送状态

### 3. 多车牌号测试
1. 提交包含多个车牌号的预约（如：京A12345,京B67890）
2. 检查推送消息中车牌号是否正确显示
3. 测试超长车牌号字符串的截断功能

## 注意事项

1. **模板ID配置**：必须在微信公众平台申请对应的模板消息并配置模板ID
2. **openid获取**：确保用户已在小程序或公众号授权，`user_mapping`表中有对应记录
3. **网络环境**：服务器需要能访问微信API服务器（api.weixin.qq.com）
4. **access_token**：系统会自动获取和管理access_token，无需手动处理
5. **推送频率**：注意微信模板消息的推送频率限制

## 文件修改清单

### 后端文件
1. `WeChatTemplateMessageService.java` - 添加接口方法
2. `WeChatTemplateMessageServiceImpl.java` - 实现推送逻辑
3. `AppointmentController.java` - 添加推送调用和依赖注入
4. `application.yml` - 添加模板ID配置

### 数据库依赖
- `user_mapping`表：存储用户手机号与微信openid的映射关系

## 后续优化建议

1. **批量推送**：如果一次预约包含很多车牌，可以考虑分批推送
2. **重试机制**：推送失败时可以添加自动重试机制
3. **推送记录**：可以添加推送记录表，记录每次推送的详细信息
4. **用户订阅管理**：允许用户选择是否接收此类通知

---

**实现日期**：2024-12-03  
**实现人员**：Cascade AI  
**版本**：v1.0
