# 避免重复通知 - 方案1实现说明

## 📋 问题背景

使用范围判断后（剩余14-15分钟、4-5分钟、0-1分钟），同一辆车可能在2分钟窗口内收到**重复通知**。

### 重复场景举例

车辆10:00:30进场：
- **11:45:00** 检查：剩余15.5分钟 → 在`14-15`范围 → **发送** ✅
- **11:46:00** 检查：剩余14.5分钟 → 在`14-15`范围 → **又发送** ❌ 重复！

---

## ✅ 解决方案：内存缓存去重

### 核心思路

使用 `ConcurrentHashMap` 记录每个预约在每个时间点的发送历史，5分钟内不重复发送。

### 实现细节

#### 1. 缓存数据结构

```java
/**
 * 发送记录缓存：避免重复发送
 * Key格式：appointmentId_notifyPoint（如："123_15" 表示预约ID 123 在15分钟时间点）
 * Value：最后发送时间
 */
private final Map<String, LocalDateTime> notificationSentCache = new ConcurrentHashMap<>();
```

#### 2. 核心方法

##### ① 生成缓存键
```java
private String generateCacheKey(Integer appointmentId, long notifyPoint) {
    return appointmentId + "_" + notifyPoint;
}
```

**示例**：
- 预约ID=123，15分钟通知 → Key=`"123_15"`
- 预约ID=456，5分钟通知 → Key=`"456_5"`

##### ② 检查是否已发送
```java
private boolean isAlreadySent(String cacheKey) {
    LocalDateTime lastSentTime = notificationSentCache.get(cacheKey);
    if (lastSentTime == null) {
        return false;  // 从未发送过
    }
    
    // 如果距离上次发送不到5分钟，认为是重复
    LocalDateTime fiveMinutesAgo = LocalDateTime.now().minusMinutes(5);
    return lastSentTime.isAfter(fiveMinutesAgo);
}
```

**逻辑**：
- 缓存中不存在 → 未发送 → 返回false
- 存在且5分钟内 → 已发送 → 返回true（阻止重复）
- 存在但超过5分钟 → 可以再发 → 返回false

##### ③ 标记为已发送
```java
private void markAsSent(String cacheKey) {
    notificationSentCache.put(cacheKey, LocalDateTime.now());
    log.debug("📝 [缓存] 记录发送 - Key: {}, 时间: {}", cacheKey, LocalDateTime.now());
}
```

##### ④ 清理过期缓存
```java
private void cleanExpiredCache() {
    LocalDateTime thirtyMinutesAgo = LocalDateTime.now().minusMinutes(30);
    int beforeSize = notificationSentCache.size();
    
    notificationSentCache.entrySet().removeIf(entry -> 
        entry.getValue().isBefore(thirtyMinutesAgo)
    );
    
    int afterSize = notificationSentCache.size();
    if (beforeSize > afterSize) {
        log.debug("🧹 [缓存清理] 清理过期记录 - 清理前: {}, 清理后: {}, 删除: {}", 
            beforeSize, afterSize, beforeSize - afterSize);
    }
}
```

**清理时机**：每次定时任务执行时自动清理30分钟前的记录

#### 3. 发送流程改造

```java
if (shouldNotify) {
    // ① 生成缓存键
    String cacheKey = generateCacheKey(appointment.getId(), notifyPoint);
    
    // ② 检查是否已发送
    if (!isAlreadySent(cacheKey)) {
        // ③ 发送通知
        boolean sent = sendTimeoutNotification(appointment, notifyPoint);
        if (sent) {
            // ④ 标记为已发送
            markAsSent(cacheKey);
            totalNotified++;
        }
    } else {
        log.debug("⏭️ [定时任务] 跳过重复发送 - 车牌: {}, 时间点: {}分钟（已在缓存中）", 
            appointment.getPlatenumber(), notifyPoint);
    }
}
```

---

## 📊 效果演示

### 场景：车辆10:00:30进场

| 时刻 | 剩余时间 | 缓存状态 | 操作 | 结果 |
|------|---------|---------|------|------|
| 11:45:00 | 15.5分钟 | 无记录 | 发送 ✅ | Key=`123_15` 记录到缓存 |
| 11:46:00 | 14.5分钟 | 有记录（1分钟前） | **跳过** ✅ | 避免重复！|
| 11:47:00 | 13.5分钟 | 有记录（2分钟前） | 跳过 | 不在范围 |
| 11:55:00 | 5.5分钟 | 无记录 | 发送 ✅ | Key=`123_5` 记录到缓存 |
| 11:56:00 | 4.5分钟 | 有记录（1分钟前） | **跳过** ✅ | 避免重复！|
| 11:59:00 | 1.5分钟 | 无记录 | 发送 ✅ | Key=`123_1` 记录到缓存 |
| 12:00:00 | 0.5分钟 | 有记录（1分钟前） | **跳过** ✅ | 避免重复！|

**结果**：每个时间点（15/5/1分钟）只发送一次通知！✅

---

## 🎯 优势分析

### 1. **完全避免重复** ✅
- 同一预约在同一时间点5分钟内只发送一次
- 不同时间点可以正常发送

### 2. **内存占用小** ✅
- 每个缓存记录只占约50字节
- 100辆活跃车 × 3个时间点 = 300条记录 ≈ 15KB
- 自动清理30分钟前的记录

### 3. **性能开销低** ✅
- ConcurrentHashMap查询O(1)时间复杂度
- 无需查询数据库
- 线程安全

### 4. **日志清晰** ✅
```log
⏰ [定时任务] 停车超时监控开始执行
🧹 [缓存清理] 清理过期记录 - 清理前: 150, 清理后: 100, 删除: 50
📧 [定时任务] 发送超时提醒 - 车牌: 京A12345, 预约类型: 邀请, 剩余: 15分钟
📝 [缓存] 记录发送 - Key: 123_15, 时间: 2024-12-04 11:45:00
⏭️ [定时任务] 跳过重复发送 - 车牌: 京A12345, 时间点: 15分钟（已在缓存中）
```

---

## ⚙️ 配置说明

### 可调整参数

#### 1. 重复判定时间窗口（当前：5分钟）

```java
// 在 isAlreadySent() 方法中
LocalDateTime fiveMinutesAgo = LocalDateTime.now().minusMinutes(5);
```

**建议值**：
- 保守：10分钟（确保不重复，但可能漏掉晚到的通知）
- 推荐：5分钟（平衡重复和漏发）
- 激进：2分钟（允许一定重复，确保不漏发）

#### 2. 缓存清理时间（当前：30分钟）

```java
// 在 cleanExpiredCache() 方法中
LocalDateTime thirtyMinutesAgo = LocalDateTime.now().minusMinutes(30);
```

**建议值**：30-60分钟

---

## 🔍 测试验证

### 测试场景1：正常发送

```
车辆10:00:00进场
→ 11:45:00：发送15分钟提醒 ✅
→ 11:55:00：发送5分钟提醒 ✅
→ 11:59:00：发送1分钟提醒 ✅
```

### 测试场景2：避免重复

```
车辆10:00:30进场
→ 11:45:00：剩余15.5分钟，发送 ✅（首次）
→ 11:46:00：剩余14.5分钟，跳过 ✅（缓存中）
→ 11:55:00：剩余5.5分钟，发送 ✅（新时间点）
→ 11:56:00：剩余4.5分钟，跳过 ✅（缓存中）
```

### 测试场景3：多辆车互不影响

```
车辆A（ID=123）：发送15分钟提醒 → Key=123_15
车辆B（ID=456）：发送15分钟提醒 → Key=456_15
→ 互不影响，都能正常发送 ✅
```

---

## 📝 注意事项

### 1. 服务重启

服务重启后缓存清空，但不影响功能：
- 重启后重新开始记录
- 最多导致一次重复发送（概率很低）

### 2. 并发安全

使用 `ConcurrentHashMap` 保证线程安全：
- 多个线程同时访问无问题
- 无需额外加锁

### 3. 内存管理

自动清理机制：
- 每分钟清理一次过期记录
- 内存占用始终保持在合理范围

---

## ✨ 总结

### 实现效果

- ✅ **完全避免重复通知**
- ✅ **内存占用小**（约15KB）
- ✅ **性能开销低**（O(1)查询）
- ✅ **自动清理过期数据**
- ✅ **线程安全**
- ✅ **日志清晰完整**

### 推荐配置

- ⏰ **检查频率**：每1分钟
- 📊 **范围判断**：14-15、4-5、0-1分钟
- 🔒 **重复窗口**：5分钟
- 🧹 **清理周期**：30分钟

---

**实现时间**：2024-12-04  
**实现人**：AI Assistant  
**文件位置**：`ParkingTimeoutMonitoringTask.java`
