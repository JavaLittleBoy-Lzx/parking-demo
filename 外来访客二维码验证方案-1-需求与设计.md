# 外来访客二维码验证方案 - 第1部分：需求与设计

## 文档信息
- **版本**: v1.0  
- **日期**: 2025-11-23  
- **状态**: 设计完成，待实施

---

## 1. 需求背景

### 1.1 业务场景

智慧停车系统需要支持三种访客类型：
1. **受邀访客**：由管家邀请，有完整地址信息
2. **外来访客**：扫描车场二维码临时访问  
3. **未知访客**：无任何扫码信息，拒绝访问

### 1.2 核心挑战

#### 挑战1：固定二维码的时效性问题
- 车场二维码需要印刷张贴在车道入口
- 无法使用动态时间戳验证（原计划1分钟过期失效）
- 二维码必须长期有效

#### 挑战2：二维码传播问题
- 访客可以拍照传播二维码
- 他人获得照片后也能扫码登录
- 存在恶意预约风险

#### 挑战3：虚假预约问题
- 访客在家里扫描照片登录
- 填写预约信息但不到现场
- 占用车位资源，影响真实用户

#### 挑战4：小程序技术限制
- 微信小程序的 `wx.scanCode` 无法区分扫描源
- 无法判断是扫现场二维码还是照片
- 需要其他技术手段验证

---

## 2. 问题分析

### 2.1 原有设计的缺陷

```
原设计：车场二维码带时间戳
URL: https://xxx?qrId=11802&timestamp=1732348920000

问题：
❌ timestamp是固定的（印刷时生成）
❌ 1分钟过期验证无法实现
❌ 任何人扫码都获得相同参数
```

### 2.2 安全风险分析

| 风险类型 | 描述 | 影响 |
|---------|------|------|
| **身份持久化** | 首次扫码登录后24小时有效，期间不退出小程序无需再扫码 | 中等 |
| **远程预约** | 在家扫照片登录，填写预约但不到现场 | 高 |
| **二维码传播** | 访客A拍照发给B、C、D...，多人共用 | 中等 |
| **资源占用** | 虚假预约占用车位资源，影响真实用户 | 高 |

### 2.3 技术约束

| 技术点 | 可行性 | 说明 |
|--------|--------|------|
| 动态时间戳 | ❌ 不可行 | 固定印刷无法动态更新 |
| 扫描源识别 | ❌ 不可行 | 小程序API无此能力 |
| GPS定位 | ✅ 可行 | 需用户授权，有10-50米误差 |
| 动态Token | ✅ 可行 | 后端实时生成，Redis存储 |
| 蓝牙信标 | ⚠️ 可行 | 成本高，需硬件设备 |

---

## 3. 访客分类体系

### 3.1 访客类型对比表

| 类型 | 识别标识 | 二维码类型 | 地址要求 | openid | 有效期 |
|------|---------|-----------|---------|--------|--------|
| **受邀访客** | `butlerId` | 管家生成，一次性 | 完整地址，锁定 | 必须 | 管家设置 |
| **外来访客** | `qrId` | 车场固定码 | 自选小区 | 不需要 | 24小时 |
| **未知访客** | 无 | - | - | - | 拒绝访问 |

### 3.2 二维码URL设计

#### 受邀访客二维码（管家生成）
```
https://xxx/verify/butler?
  butlerId=10001&
  applyKind=2&
  butlerName=张管家&
  community=欧洲新城&
  building=1&unit=2&floor=3&room=301
```

#### 外来访客二维码（车场固定）
```
https://xxx/verify/parking?
  qrId=11802&
  community=欧洲新城&
  type=parking_entrance
```

**关键改变**：
- ❌ 去掉 `timestamp` 字段（因为是固定印刷）
- ✅ 增加 `type=parking_entrance` 标识二维码类型  
- ✅ `qrId` 作为车场唯一标识

---

## 4. 技术方案设计

### 4.1 核心验证机制

#### 机制1：GPS位置验证 ⭐⭐⭐⭐⭐
**目的**：确保用户在车场现场

```
验证流程：
1. 用户扫码 → 前端获取GPS位置
2. 调用后端 verifyLocation(qrId, lat, lng)
3. 后端计算距离 = Haversine(用户位置, 车场位置)
4. 距离 < 500米 → 通过 ✅
5. 距离 >= 500米 → 拒绝 ❌
```

**Haversine公式**（计算地球表面两点距离）：
```
a = sin²(Δlat/2) + cos(lat1) × cos(lat2) × sin²(Δlon/2)
c = 2 × atan2(√a, √(1−a))
distance = R × c  // R=6371000米（地球半径）
```

#### 机制2：动态Token验证 ⭐⭐⭐⭐⭐
**目的**：防止二维码照片长期传播

```
验证流程：
1. 扫码后立即调用 getVisitorToken(qrId, location)
2. 后端生成UUID token，存入Redis，5分钟过期
3. 前端保存token和生成时间
4. 预约时验证token是否有效
5. Token使用后立即删除（一次性）
```

**Token数据结构**：
```json
{
  "token": "abc123-def456-ghi789",
  "qrId": "11802",
  "phone": "13593527970",
  "location": {"latitude": 45.7568, "longitude": 126.6425},
  "createTime": 1732348800000,
  "expiresIn": 300
}
```

#### 机制3：使用记录追踪 ⭐⭐⭐⭐
**目的**：限制单个手机号的使用频率

```
验证规则：
1. 记录 qrId + phone 的使用情况  
2. 首次扫描时间超过24小时 → 创建新记录
3. 今日使用次数超过3次 → 拒绝访问
4. 账号状态被封禁 → 拒绝访问
```

#### 机制4：身份有效期 ⭐⭐⭐⭐
**目的**：定期清理过期身份

```
验证规则：
1. 登录时设置 expiresAt = now + 24小时
2. 每次打开小程序检查是否过期
3. 过期则清除本地数据，要求重新扫码
```

### 4.2 完整验证流程图

#### 流程A：首次扫码登录（现场）✅

```
访客到达车场
    ↓
扫描车场二维码
    ↓
小程序解析 qrId=11802
    ↓
请求位置权限 → 用户授权
    ↓
获取GPS位置 (lat, lng)
    ↓
调用后端: verifyAndGetToken(qrId, phone, lat, lng)
    ↓
后端验证:
├─ 查询车场坐标
├─ 计算距离 = 120米 < 500米 ✅
├─ 查询使用记录（不存在或未超限）
├─ 创建/更新使用记录
├─ 生成token，存入Redis，5分钟过期
└─ 返回: {token, expiresAt=now+24h, distance}
    ↓
前端保存:
├─ visitorToken
├─ tokenTime
├─ expiresAt
├─ scanLocation
└─ scanTime
    ↓
登录成功，进入系统
```

#### 流程B：在家扫照片（被拦截）❌

```
访客在家中
    ↓
扫描二维码照片
    ↓
小程序解析 qrId=11802
    ↓
请求位置权限 → 用户授权
    ↓
获取GPS位置 (lat, lng)
    ↓
调用后端: verifyAndGetToken(qrId, phone, lat, lng)
    ↓
后端验证:
├─ 查询车场坐标
├─ 计算距离 = 5200米 > 500米 ❌
└─ 返回: {error: "请在车场现场扫码，当前距离5.2公里"}
    ↓
前端弹窗提示: "位置验证失败"
    ↓
拒绝登录
```

#### 流程C：超过24小时重新扫码🔄

```
访客打开小程序（上次扫码已过24小时）
    ↓
onShow检查 expiresAt
    ↓
now > expiresAt ❌ 已过期
    ↓
清除本地存储
    ↓
弹窗: "访客身份已过期，请重新扫码"
    ↓
跳转到首页
    ↓
访客重新扫码 → 执行流程A
```

#### 流程D：达到使用次数上限🚫

```
访客再次扫码（今天第4次）
    ↓
调用后端: verifyAndGetToken(qrId, phone, lat, lng)
    ↓
后端查询使用记录:
├─ lastScanTime = 今天
├─ scanCount = 3
└─ 判断: 3 >= 3 ❌ 超限
    ↓
返回: {error: "今日使用次数已达上限(3次)"}
    ↓
前端弹窗提示
    ↓
拒绝访问
```

### 4.3 预约验证策略

#### 策略1：扫码时间限制（推荐）

```javascript
// 预约提交时检查
const scannedParams = uni.getStorageSync('scannedParams');
const scanTime = scannedParams?.scanTime || 0;
const timeDiff = (Date.now() - scanTime) / 1000 / 60; // 分钟

if (timeDiff > 10) {
    // 扫码时间超过10分钟，要求重新扫码
    uni.showModal({
        title: '请重新扫码',
        content: '为确保您在车场现场，请重新扫描车道二维码后再预约',
        showCancel: false
    });
    return;
}
```

**参数说明**：
- 10分钟时间窗口：从车道扫码 → 走到办事处 → 填写预约
- 超过10分钟认为可能不在现场

#### 策略2：Token验证

```javascript
// 预约提交时验证token
const token = scannedParams?.visitorToken;
const tokenTime = scannedParams?.tokenTime || 0;
const tokenAge = (Date.now() - tokenTime) / 1000 / 60; // 分钟

if (!token || tokenAge > 5) {
    uni.showToast({
        title: 'Token已过期，请重新扫码',
        icon: 'none'
    });
    return;
}

// 提交时带上token
await request({
    url: '/appointment/create',
    data: {
        ...formData,
        visitorToken: token,
        qrId: scannedParams.qrId
    }
});
```

**参数说明**：
- Token有效期：5分钟
- 每个token只能使用一次
- 后端验证token并删除

### 4.4 关键参数配置

```javascript
const EXTERNAL_VISITOR_CONFIG = {
    // GPS验证
    maxDistance: 500,                // 最大允许距离（米）
    
    // Token配置
    tokenExpireMinutes: 5,           // Token有效期（分钟）
    
    // 扫码时间限制
    scanValidMinutes: 10,            // 扫码有效时间（分钟）
    
    // 身份有效期
    identityExpireHours: 24,         // 访客身份有效期（小时）
    
    // 使用次数限制
    maxUsesPerDay: 3,                // 每天最多使用次数
    maxAppointmentsPerDay: 3,        // 每天最多预约次数
    
    // 预约时间限制
    minAdvanceMinutes: 30,           // 最少提前时间（分钟）
    maxAdvanceMinutes: 120           // 最多提前时间（分钟）
};
```

---

## 5. 优势与限制

### 5.1 方案优势

| 优势 | 说明 |
|------|------|
| **适配固定二维码** | 不依赖timestamp，适合印刷张贴 |
| **安全可控** | GPS+Token双重验证，后端记录可追溯 |
| **用户体验好** | 24小时内免扫码，自动验证无感知 |
| **可扩展性强** | 参数可配置，支持不同车场不同规则 |
| **成本低** | 不需要额外硬件设备 |

### 5.2 方案限制

| 限制 | 影响 | 缓解方案 |
|------|------|---------|
| **GPS精度** | 10-50米误差，室内信号弱 | 设置500米容差范围 |
| **需要授权** | 用户可能拒绝位置权限 | 提示说明，引导授权 |
| **依赖网络** | 网络异常影响验证 | 本地缓存+离线降级 |
| **可伪造GPS** | 专业用户可用工具伪造 | 普通用户不会，可接受 |

---

**下一部分：[数据库设计与前端实现](./外来访客二维码验证方案-2-数据库与前端.md)**
