# 业主预约后查询管家昵称并发送通知功能说明

## 功能概述

业主在小程序填写预约表单后，系统会自动查询当前车场的管家信息，获取管家的微信昵称，然后通过微信公众号发送预约待审核通知给管家。

## 实现流程

```
业主提交预约表单
    ↓
预约数据保存成功
    ↓
前端调用查询管家昵称接口 (/api/wechat/butler-nickname/{community})
    ↓
后端查询逻辑：
    1. 根据车场名称查询 butler 表，获取该车场的所有管家信息
    2. 遍历所有管家，提取手机号
    3. 通过手机号在 user_mapping 表查询对应的微信昵称
    4. 分为两种情况：
       a) 找到至少一个已关注公众号的管家
          - 返回其昵称和其他未关注管家列表
       b) 所有管家都未关注公众号
          - 返回所有管家的姓名和手机号
    ↓
前端判断查询结果：
    情况A：有已关注的管家
        ↓
        获取管家昵称
        ↓
        调用发送通知接口 (/api/wechat/send/booking-pending-notification)
        参数包含：车牌号、车场名称、预约人、联系电话、管家昵称
        ↓
        后端通过管家昵称查询 openid，并发送微信模板消息
        ↓
        （可选）在控制台提示其他未关注的管家信息
    
    情况B：所有管家都未关注
        ↓
        显示弹窗提示用户
        ↓
        列出所有管家的姓名和手机号
        ↓
        建议用户通过其他方式联系管家
        ↓
        不发送微信通知
```

## 后端实现

### 1. 新增接口

**文件位置**: `src/main/java/com/parkingmanage/controller/WeChatNotificationController.java`

**接口地址**: `GET /api/wechat/butler-nickname/{community}`

**功能**: 根据车场名称查询管家的微信昵称

**处理流程**:
1. 调用 `ButlerService.getAllButlersByCommunity(community)` 查询该车场的所有管家
2. 获取第一个管家的手机号
3. 调用 `UserMappingService.getByPhone(phone)` 通过手机号查询 user_mapping 表
4. 返回查询到的 nickname

**返回数据结构**:

情况1：找到已关注公众号的管家
```json
{
  "code": "0",
  "message": "操作成功",
  "data": {
    "success": true,
    "nickname": "张管家",
    "butlerName": "张三",
    "phone": "13800138000",
    "community": "阳光小区",
    "hasUnfollowedButlers": true,
    "unfollowedButlers": [
      {
        "butlerName": "李四",
        "phone": "13900139000"
      }
    ]
  }
}
```

情况2：所有管家都未关注公众号
```json
{
  "code": "0",
  "message": "操作成功",
  "data": {
    "success": false,
    "message": "该车场的管家尚未关注公众号，无法接收通知",
    "unfollowedButlers": [
      {
        "butlerName": "张三",
        "phone": "13800138000"
      },
      {
        "butlerName": "李四",
        "phone": "13900139000"
      }
    ],
    "community": "阳光小区",
    "totalButlers": 2
  }
}
```

### 2. 依赖的服务

- **ButlerService**: 管家服务，用于查询管家信息
  - 方法: `getAllButlersByCommunity(String community)`
  - 返回: `List<Butler>`

- **UserMappingService**: 用户映射服务，用于查询微信信息
  - 方法: `getByPhone(String phone)`
  - 返回: `UserMapping`

### 3. 数据表结构

**butler 表**:
- `id`: 主键
- `username`: 管家姓名
- `phone`: 管家手机号
- `community`: 所属车场
- `openid`: 微信 openid（可能为空）

**user_mapping 表**:
- `id`: 主键
- `nickname`: 微信昵称
- `openid`: 微信 openid
- `phone`: 手机号
- `is_followed`: 是否关注公众号

## 前端实现

### 1. 修改文件

**文件位置**: `pagesA/reservation/form.vue`

**修改方法**: `sendBookingPendingNotification(appointmentData, parkingLotName)`

### 2. 实现逻辑

```javascript
async sendBookingPendingNotification(appointmentData, parkingLotName) {
  // 1. 先查询车场管家昵称
  const butlerResponse = await request({
    url: `/parking/api/wechat/butler-nickname/${encodeURIComponent(parkingLotName)}`,
    method: 'GET'
  });
  
  // 2. 处理查询结果
  if (butlerResponse.code === '0' && butlerResponse.data) {
    // 情况1：所有管家都未关注
    if (butlerResponse.data.success === false) {
      this.showUnfollowedButlersAlert(
        butlerResponse.data.unfollowedButlers, 
        parkingLotName
      );
      return { success: false, message: '管家未关注公众号' };
    }
    
    // 情况2：找到已关注的管家
    if (butlerResponse.data.nickname) {
      const managerNickname = butlerResponse.data.nickname;
      
      // 发送通知
      const response = await request({
        url: '/parking/api/wechat/send/booking-pending-notification',
        method: 'POST',
        data: {
          plateNumber: appointmentData.platenumber,
          parkName: parkingLotName,
          bookerName: appointmentData.visitorname,
          contactPhone: appointmentData.visitorphone,
          managerNickname: managerNickname
        }
      });
      
      // 如果有其他未关注的管家，在控制台记录
      if (butlerResponse.data.hasUnfollowedButlers) {
        this.showPartialUnfollowedButlersHint(
          butlerResponse.data.unfollowedButlers
        );
      }
      
      return response;
    }
  }
}

// 显示管家未关注提示弹窗
showUnfollowedButlersAlert(unfollowedButlers, parkingLotName) {
  let butlerList = unfollowedButlers.map((butler, index) => {
    return `${index + 1}. ${butler.butlerName} (${butler.phone})`;
  }).join('\n');
  
  uni.showModal({
    title: '⚠️ 管家尚未关注公众号',
    content: `您的预约已成功提交！\n\n但 ${parkingLotName} 的管家尚未关注公众号，无法接收预约审核提醒。\n\n请联系以下管家关注公众号：\n${butlerList}\n\n建议通过其他方式（如电话）通知管家审核预约。`,
    showCancel: false,
    confirmText: '我知道了',
    confirmColor: '#ff9500'
  });
}
```

### 3. 调用时机

在预约提交成功后，如果预约状态为"待审批"，则自动调用此方法：

```javascript
// 在 submitAppointment 方法中
if (auditStatus === '待审批') {
  await this.sendBookingPendingNotification(appointmentData, parkingLotName);
}
```

## 错误处理与用户体验

### 1. 所有管家都未关注公众号
**后端处理**:
- 返回 `success: false`
- 提供完整的未关注管家列表（姓名+手机号）

**前端处理**:
- 显示友好的提示弹窗
- 列出所有管家的联系方式
- 建议用户通过电话等其他方式联系
- **不发送微信通知**

**用户看到的提示**:
```
⚠️ 管家尚未关注公众号

您的预约已成功提交！

但 阳光小区 的管家尚未关注公众号，无法接收预约审核提醒。

请联系以下管家关注公众号：
1. 张三 (13800138000)
2. 李四 (13900139000)

建议通过其他方式（如电话）通知管家审核预约。
```

### 2. 部分管家已关注
**后端处理**:
- 返回已关注管家的昵称
- 同时返回未关注管家列表

**前端处理**:
- 使用已关注管家的昵称发送通知
- 在控制台记录其他未关注管家的信息（不打扰用户）
- **成功发送微信通知**

### 3. 查询管家信息失败
**场景**: 网络错误、数据库异常等
**处理**: 
- 使用默认昵称"小区管家"
- 记录错误日志
- 继续发送通知（尽力而为）

### 4. 管家信息不存在
**场景**: 车场没有配置管家
**后端返回**: "未找到该车场的管家信息"
**前端处理**: 使用默认昵称，继续发送通知

### 5. 发送通知失败
**处理**:
- 记录错误日志
- **不影响预约成功状态**
- 用户仍然可以看到预约成功提示
- 预约数据已保存，审核可正常进行

## 测试要点

### 1. 正常流程测试
- [ ] 业主提交预约，车场有已关注公众号的管家
- [ ] 成功查询到管家昵称
- [ ] 成功发送通知给管家
- [ ] 管家收到微信公众号通知
- [ ] 预约成功提示正常显示

### 2. 所有管家未关注场景
- [ ] 业主提交预约，车场的所有管家都未关注公众号
- [ ] 返回所有管家的姓名和手机号
- [ ] 前端显示提示弹窗，列出管家联系方式
- [ ] 不发送微信通知
- [ ] 预约状态正常（已提交待审核）

### 3. 部分管家未关注场景
- [ ] 业主提交预约，车场有多个管家，部分已关注
- [ ] 返回已关注管家的昵称和未关注管家列表
- [ ] 使用已关注管家的昵称发送通知
- [ ] 在控制台记录未关注管家信息
- [ ] 通知成功发送

### 4. 异常场景测试
- [ ] 车场没有配置管家时，返回错误信息
- [ ] 管家手机号为空时，跳过该管家
- [ ] 网络异常时，使用默认昵称继续流程
- [ ] 查询超时时，使用默认昵称

### 5. 用户体验测试
- [ ] 提示弹窗文案清晰友好
- [ ] 管家列表格式易读（带序号和手机号）
- [ ] 用户能够理解下一步操作
- [ ] 预约成功状态不受通知发送影响

### 6. 性能测试
- [ ] 查询管家昵称接口响应时间 < 2秒
- [ ] 整个通知流程不影响预约提交速度
- [ ] 多个管家遍历查询性能可接受

## 日志输出

### 后端日志
```
🔍 查询管家昵称 - 车场: 阳光小区
📱 找到管家手机号 - 车场: 阳光小区, 管家: 张三, 手机: 13800138000
✅ 查询管家昵称成功 - 车场: 阳光小区, 管家: 张三, 昵称: 张管家
```

### 前端日志
```
📧 [发送通知] 开始发送预约待审核通知
🔍 [查询管家] 开始查询车场管家昵称 - 车场: 阳光小区
✅ [查询管家] 成功获取管家昵称: 张管家
📧 [发送通知] 请求参数: {...}
✅ [发送通知] 预约待审核通知发送成功
```

## 相关接口文档

### 查询管家昵称接口

**请求**:
```
GET /api/wechat/butler-nickname/{community}
```

**参数**:
- `community` (路径参数): 车场名称，需要 URL 编码

**响应**:
```json
{
  "code": "0",
  "message": "操作成功",
  "data": {
    "nickname": "张管家",
    "butlerName": "张三",
    "phone": "13800138000",
    "community": "阳光小区"
  }
}
```

### 发送预约通知接口

**请求**:
```
POST /api/wechat/send/booking-pending-notification
Content-Type: application/json
```

**请求体**:
```json
{
  "plateNumber": "京A12345",
  "parkName": "阳光小区",
  "bookerName": "李四",
  "contactPhone": "13900139000",
  "managerNickname": "张管家"
}
```

**响应**:
```json
{
  "code": "0",
  "message": "操作成功",
  "data": {
    "success": true,
    "message": "通知发送成功"
  }
}
```

## 注意事项

1. **车场名称匹配**: 确保前端传递的车场名称与 butler 表中的 community 字段完全一致
2. **管家关注状态**: 管家必须已关注微信公众号，才能在 user_mapping 表中查询到昵称
3. **容错处理**: 所有查询失败都使用默认昵称，保证通知流程能够继续
4. **异步处理**: 通知发送失败不影响预约成功状态
5. **URL 编码**: 车场名称包含中文时需要进行 URL 编码

## 后续优化建议

1. **缓存优化**: 考虑缓存管家昵称，减少数据库查询
2. **多管家处理**: 当车场有多个管家时，支持通知所有管家
3. **通知模板**: 优化通知模板内容，添加更多预约信息
4. **重试机制**: 通知发送失败时增加重试机制
5. **统计功能**: 记录通知发送成功率，便于监控和优化
